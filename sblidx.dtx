% \iffalse meta-comment
%
% Copyright (c) 2025 David Purton <dcpurton@marshwiggle.net>
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3c of this license
% or (at your option) any later version. The latest version of this
% license is in
%    http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
%<*driver>
\RequirePackage{pdfmanagement}
\documentclass[a4paper]{ltxdoc}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{mlmodern}
\usepackage{sblidx}

\AddToHook{env/macrocode/before}{%
  \addvspace{\medskipamount}}

\AddToHook{env/macro/before}{%
  \addvspace{\medskipamount}}

\renewcommand*{\MakePrivateLetters}{%
  \catcode`\@=11\relax
  \catcode`\_=11\relax
  \catcode`\:=11\relax}

\begin{document}
\DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \pkg{sblidx} Package}
% \author{David Purton\thanks{Email: \url{dcpurton@marshwiggle.net}}}
% \date{2025/07/18 v1.0}
%
% \maketitle
%
% \begin{abstract}
%   The \pkg{sblidx} package provides a \LaTeX\ style for creating indices in
%   a style recommended by the Society of Biblical Literature as outlined in
%   the \emph{Society of Biblical Literature Handbook of Style} and
%   \emph{Preparing Indices}.\footnote{See \emph{The SBL Handbook of Style:
%   For Biblical Studies and Related Disciplines}, 2nd ed.\@ (SBL Press,
%   2014); SBL Publications, \emph{Preparing Indices},
%   \url{https://www.sbl-site.org/wp-content/uploads/2024/05/Indexing_SBL.pdf}.}
%   This includes producing an index of ancient sources with the help of the
%   \pkg{bibleref-sbl} package, an index of modern authors with the help of
%   the \pkg{biblatex-sbl} package and an index of subjects. Page ranges are
%   automatically compressed and when indexed entries appear in footnotes they
%   are indicated with n.\ and nn.
% \end{abstract}
%
% \tableofcontents
%
% \section{Introduction}
%
% \subsection{Usage}
%
% \subsection{Bug Reports and Feature Requests}
%
% Bug reports and feature requests can be made at the \pkg{sblidx}
% GitHub repository. See \url{https://github.com/dcpurton/sblidx}.
%
% \section{Package Options}
%
% \section{Commands}
%
% \section{Implementation}
%
% \setlength{\parindent}{0em}
%
% \subsection{Custom Index Style File}
%
%    \begin{macrocode}
%<*indexstyle>
%    \end{macrocode}
%
% Custom index style file which wraps the list of pages with the command
% \cs{ProcessIndexPages} and removes the default comma delimiter before the
% first page number for an entry. SBL only uses a comma for the Subject Index.
%
%    \begin{macrocode}
delim_0 "\\SBLProcessIndexPages{"
delim_1 "\\SBLProcessIndexPages{"
delim_2 "\\SBLProcessIndexPages{"
delim_t "}"
%    \end{macrocode}
%
%    \begin{macrocode}
%</indexstyle>
%    \end{macrocode}
%
% \subsection{Main Package}
%
%    \begin{macrocode}
%<*package>
%<@@=sblidx>
%    \end{macrocode}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesExplPackage{sblidx}{2025/07/18}{1.0}
  {Society of Biblical Literature Indices (DCP)}
%    \end{macrocode}
%
% Load \pkg{imakeidx} and \pkg{idxlayout} with appropriate options. Most
% layout is controlled with \pkg{idxlayout}, but \pkg{imakeidx} provides an
% interface for setting the index title and the convenience of running
% |makeindex| inline.
%
%    \begin{macrocode}
\RequirePackage{imakeidx}
\RequirePackage{idxlayout}
\idxlayout
  {
    columnsep    = 0.5in          ,
    font         = small          ,
    hangindent   = 0.25in         ,
    initsep      = \bigskipamount ,
    itemlayout   = relhang        ,
    subindent    = 0.25in         ,
    subsubindent = 0.5in          ,
    totoc
  }
%    \end{macrocode}
%
% \subsubsection{Define and Process Package Options}
%
%    \begin{macrocode}
\keys_define:nn { sblidx }
  {
    ancient~sources       .bool_set:N = \l_@@_ancient_sources_bool     ,
    ancient~sources~title .tl_set:N   = \l_@@_ancient_sources_title_tl ,
    ancient sources title .initial:n  = Ancient~Sources~Index          ,
    modern~authors        .bool_set:N = \l_@@_modern_authors_bool      ,
    modern~authors~title  .tl_set:N   = \l_@@_modern_authors_title_tl  ,
    modern~authors~title  .initial:n  = Modern~Authors~Index           ,
    subject               .bool_set:N = \l_@@_subject_bool             ,
    subject               .initial:n  = true                           ,
    subject~title         .tl_set:N   = \l_@@_subject_title_tl         ,
    subject~title         .initial:n  = Subject~Index                  ,
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyOptions
%    \end{macrocode}
%
% \subsubsection{Set Up Indices}
%
% The delimiter between the indexed entry and the first page is dependent on
% the index type, so it is set dynamically in \cs{SBLPrintIndices}.
%
%    \begin{macrocode}
\tl_const:Nn \c_@@_delim_tl { , \c_space_tl }
\tl_new:N \l_@@_delim_first_tl
\tl_const:Nn \c_@@_delim_see_tl { . \c_space_tl }
%    \end{macrocode}
%
% Call \cs{makeindex} for each required index.
%
%    \begin{macrocode}
\bool_if:NT \l_@@_subject_bool
  {
    \makeindex
      [
        title   = \l_@@_subject_title_tl ,
        options = -s~sblidx.ist~-q
      ]
  }
%    \end{macrocode}
%
% Set up \cs{footnote} so that \cs{index} includes the footnote number when
% indexing an entry in a footnote.
%
% \begin{macro}{\@@_set_up_footnotes:}Footnote set up code.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_set_up_footnotes:
  {
    \cs_set_eq:NN \@@_index:nn \index
    \bool_if:NT \l_@@_ancient_sources_bool
      {
        \cs_set_nopar:Npn \biblerefindex
          { \@@_index:nn [ \jobname-ancient-sources ] }
        \cs_set_nopar:Npn \bvidxpgformat
          { SBLPageWithNote { \thefootnote } }
      }
    \cs_set_nopar:Npn \index { \SBLFootnoteIndex }
  }
%    \end{macrocode}
% \end{macro}
%
% For new footnote code, the set up can be injected with hooks. Otherwise the
% \cmd{footnote} command must be redefined. Note that in the latter case if
% you or some other package again redefines \cs{footnote} after loading
% \pkg{sblidx} automatically including note numbers with indexed entries in
% footnotes will not work.
%
%    \begin{macrocode}
\IfDocumentMetadataTF
  {
    \hook_gput_code:nnn { fntext } { sblidx } { \@@_set_up_footnotes: }
  }
  {
    \cs_set_eq:NN \@@_footnote: \footnote
    \RenewDocumentCommand { \footnote } { o+m }
      {
        \group_begin:
          \@@_set_up_footnotes:
          \tl_if_novalue:nTF {#1}
            { \@@_footnote: {#2} }
            { \@@_footnote: [#1] {#2} }
        \group_end:
      }
  }
%    \end{macrocode}
%
% \begin{macro}{\see, \seealso}
%   SBL want \emph{See} and \emph{See also} to begin a new sentence so
%   redefine \cs{see} and \cs{seealso} to capitalise the first letter of
%   \emph{See}.
%
%    \begin{macrocode}
\cs_set_nopar:Npn \see #1 #2
  {
    \emph { \text_titlecase_first:n { \seename } }
    \c_space_tl #1
  }
\cs_set_nopar:Npn \seealso #1 #2
  {
    \emph { \text_titlecase_first:n { \alsoname } }
    \c_space_tl #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SBLFootnoteIndex} \oarg{name} \marg{entry}
%
%   \medskip
%
%   \cs{index} is defined to this macro within footnotes so that note numbers
%   are automatically included unless some other formatting is requested by
%   the user. \meta{name} is the name of the raw index file and \meta{entry}
%   should be formatted according to syntax required by |makeindex|.
%
%    \begin{macrocode}
\NewDocumentCommand { \SBLFootnoteIndex } { om }
  {
    \tl_if_novalue:nTF {#1}
      {
        \str_if_in:nnTF {#2} { | }
          { \@@_index:nn {#2} }
          {
            \@@_index:nn
              { #2 | SBLPageWithNote { \thefootnote } }
          }
      }
      {
        \str_if_in:nnTF {#2} { | }
          { \@@_index:nn [#1] {#2} }
          {
            \@@_index:nn [ #1 ]
              { #2 | SBLPageWithNote { \thefootnote } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SBLPageWithNote} \marg{comma separated list of notes}
%     \marg{page}
%
%   \medskip
%
%   Output page with note number using n.\ or nn.\ depending on how many notes
%   there are. This command is called automatically using the |makeindex|
%   \verb+\index{gnat|SBLPageWithNote{\thefootnote}}+ syntax when |\index|
%   appears in a footnote. It allows for a comma separated list of notes
%   because the command |\SBLProcessIndexPages| combines indexed entries in
%   footnotes on the same page into one command with the format
%   |\SBLPageWithNote{x,y,z}{page}|.
%
%    \begin{macrocode}
\cs_new_protected:Npn \SBLPageWithNote #1 #2
  {
    #2
    \c_space_tl
    \int_compare:nNnTF { \clist_count:n {#1} } > \c_one_int
      { nn. }
      { n. }
    \nobreakspace
    \@@_compress_note_list:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SBLPrintIndices}
%   Print the indices. This command prints one or more indices depending on
%   which are enabled with the |ancient sources|, |modern authors| and
%   |subject| options.
%
%    \begin{macrocode}
\cs_new_protected:Npn \SBLPrintIndices
  {
    \bool_if:NT \l_@@_subject_bool
      {
        \group_begin:
          \tl_set:Nn \l_@@_delim_first_tl { , \c_space_tl }
          \printindex
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SBLProcessIndexPages} \marg{list of pages}
%
%   \medskip
%
%   Process a list of pages produced by |makeindex|, compressing page ranges
%   and note ranges as needed according to SBL style. This function is called
%   by the required custom index style file |sblidx.ist|.
%
%    \begin{macrocode}
\cs_new_protected:Npn { \SBLProcessIndexPages } #1
  {
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Main Page and Note Compression Code}
%
% The following code handles compression of page numbers and note numbers in
% indices according to SBL requirements.
%
% \begin{macro}{\@@_compress_range:n, \@@_compress_ranges:n}
%     \marg{number range(s)}
%
%   \medskip
%
%   Compress a number range (|\@@_compress_range:n|) or comma separated
%   list of number ranges (|\@@_compress_ranges:n|) according to SBL style.
%   Non-Arabic numbers and non-ranges are returned unaltered.
%
%    \begin{macrocode}
\clist_new:N \l_@@_compressed_range_clist
\int_new:N   \l_@@_range_start_int
\int_new:N   \l_@@_range_end_int
\int_new:N   \l_@@_range_length_int
\int_new:N   \l_@@_range_end_position_int
\seq_new:N   \l_@@_range_seq
\tl_new:N    \l_@@_compressed_range_tl
\tl_new:N    \l_@@_compressed_range_end_tl
\tl_new:N    \l_@@_range_start_tl
\tl_new:N    \l_@@_range_end_tl
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_compress_range:n
  {
    \@@_get_compressed_range_end:n {#1}
    \tl_if_empty:NTF \l_@@_compressed_range_end_tl
      {#1}
      {
        \tl_set:Ne \l_@@_compressed_range_tl
          {
            \l_@@_range_start_tl
            --
            \l_@@_compressed_range_end_tl
          }
        \tl_use:N \l_@@_compressed_range_tl
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_compress_ranges:n
  {
    \clist_clear:N \l_@@_compressed_range_clist
    \clist_map_inline:nn {#1}
      {
        \clist_put_right:Nn
          \l_@@_compressed_range_clist
          { \@@_compress_range:n {##1} }
      }
    \clist_use:Nn \l_@@_compressed_range_clist { ,~ }
  }
%    \end{macrocode}
%
%   |\@@_get_compressed_range_end:n| finds the compressed end value for an
%   Arabic number range and stores it in |\l_@@_compressed_range_end_tl|.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_get_compressed_range_end:n
  {
    \tl_clear:N \l_@@_compressed_range_end_tl
%    \end{macrocode}
%
%   Only Arabic number ranges are compressed
%
%    \begin{macrocode}
    \seq_set_regex_extract_once:Nnn
      \l_@@_range_seq
      { \A(\d+)--(\d+)\Z }
      {#1}
    \int_compare:nNnT
      { \seq_count:N \l_@@_range_seq } = { 3 }
      {
        \int_set:Nn \l_@@_range_start_int
          { \seq_item:Nn \l_@@_range_seq { 2 } }
        \int_set:Nn \l_@@_range_end_int
          { \seq_item:Nn \l_@@_range_seq { 3 } }
%    \end{macrocode}
%
%   First number must be greater than 100.
%
%    \begin{macrocode}
        \int_compare:nNnT
          { \l_@@_range_start_int } > { 100 }
          {
%    \end{macrocode}
%
%   First number must not be divisible by 100.
%
%    \begin{macrocode}
            \int_compare:nNnT
              {
                \int_mod:nn
                  { \l_@@_range_start_int }
                  { 100 }
              }
              >
              { \c_zero_int }
              {
%    \end{macrocode}
%
%   Pages must be the same number of digits.
%
%    \begin{macrocode}
                \int_set:Nn \l_@@_range_length_int
                  {
                    \tl_count:e { \int_use:N \l_@@_range_start_int }
                  }
                \int_compare:nNnT
                  { \l_@@_range_length_int }
                  =
                  {
                    \tl_count:e { \int_use:N \l_@@_range_end_int }
                  }
                  {
%    \end{macrocode}
%
%   Main compression code. Step through each digit of the start number in the
%   range until the corresponding digit in the end number is different
%   \emph{or} there are only two digits left. The remaining digits of the end
%   number is the compressed value.
%
%    \begin{macrocode}
                    \tl_set:No \l_@@_range_start_tl
                      { \int_use:N \l_@@_range_start_int }
                    \tl_set:No \l_@@_range_end_tl
                      { \int_use:N \l_@@_range_end_int }
                    \int_zero:N \l_@@_range_end_position_int
                    \tl_map_inline:Nn \l_@@_range_start_tl
                      {
                        \int_incr:N \l_@@_range_end_position_int
                        \int_compare:nNnT
                          { \l_@@_range_end_position_int + 1 }
                          =
                          { \l_@@_range_length_int }
                          {
                            \tl_set:Ne
                              \l_@@_compressed_range_end_tl
                              {
                                \tl_range:Nnn
                                  \l_@@_range_end_tl
                                  { \l_@@_range_end_position_int }
                                  { \l_@@_range_length_int }
                              }
                            \tl_map_break:
                          }
                        \tl_if_eq:neF
                          {##1}
                          {
                            \tl_item:Nn
                              \l_@@_range_end_tl
                              { \l_@@_range_end_position_int }
                          }
                          {
                            \tl_set:Ne
                              \l_@@_compressed_range_end_tl
                              {
                                \tl_range:Nnn
                                  \l_@@_range_end_tl
                                  { \l_@@_range_end_position_int }
                                  { \l_@@_range_length_int }
                              }
                            \tl_map_break:
                          }
                      }
%    \end{macrocode}
%
%   Remove leading zeroes from compressed range.
%
%    \begin{macrocode}
                    \tl_regex_replace_once:Nnn
                      \l_@@_compressed_range_end_tl
                      { \A0+ }
                      { }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_compress_note_list:n} \marg{sorted note numbers}
%
%   \medskip
%
%   Format a comma separated list of note numbers to use SBL style compressed
%   ranges when there are three or more consecutive numbers.
%
%    \begin{macrocode}
\clist_new:N \l_@@_notes_clist
\clist_new:N \l_@@_compressed_notes_clist
\tl_new:N    \l_@@_note_range_start_tl
\tl_new:N    \l_@@_note_previous_tl
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_compress_note_list:n
  {
    \clist_set:Nn \l_@@_notes_clist {#1}
    \clist_clear:N \l_@@_compressed_notes_clist
    \clist_pop:NNT \l_@@_notes_clist \l_@@_note_range_start_tl
      {
        \tl_set_eq:NN \l_@@_note_previous_tl \l_@@_note_range_start_tl
        \clist_map_inline:Nn \l_@@_notes_clist
          {
            \int_compare:nNnTF {##1} = { \l_@@_note_previous_tl + 1 }
              {
                \tl_set:Nn \l_@@_note_previous_tl {##1}
              }
              {
                \@@_append_note:VV
                  \l_@@_note_range_start_tl
                  \l_@@_note_previous_tl
                \tl_set:Nn \l_@@_note_range_start_tl {##1}
                \tl_set:Nn \l_@@_note_previous_tl {##1}
              }
          }
        \@@_append_note:VV
          \l_@@_note_range_start_tl
          \l_@@_note_previous_tl
        \clist_use:Nnnn
          \l_@@_compressed_notes_clist
          { ~ and ~ } { , ~ } { , ~ and ~ }
      }
  }
%    \end{macrocode}
%
%   |\@@_append_note:nn| and the variant |\@@_append_note:VV| are helper
%   functions called by |\@@_compress_note_list:n| to append the next note or
%   note range to the current list when building a formatted list of notes.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_append_note:nn
  {
    \int_compare:nNnTF { #2 - #1 } > { \c_one_int }
      {
        \clist_put_right:Nn \l_@@_compressed_notes_clist
          {
            \@@_compress_range:n { #1 -- #2 }
          }
      }
      {
        \clist_put_right:Nn \l_@@_compressed_notes_clist {#1}
        \tl_if_eq:nnF {#1} {#2}
          {
            \clist_put_right:Nn \l_@@_compressed_notes_clist {#2}
          }
      }
  }
\cs_generate_variant:Nn \@@_append_note:nn { VV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_page_compare:nNnTF} \marg{first page number}
%     \meta{relation} \marg{second page number} \marg{true code}
%     \marg{false code}
%
%   \medskip
%
%   Compare pages taking into account Roman and Arabic page numbering systems.
%   Note that this macro only takes into account a standard book with the
%   front matter numbered with Roman numbers and the main matter numbered with
%   Arabic numbers. The relations supported are |=|, |>| and |<|. |T|, |F| and
%   |TF| variants are available.
%
%    \begin{macrocode}
\int_new:N \l_@@_first_int
\int_new:N \l_@@_second_int
%    \end{macrocode}
%
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_page_compare:nNn #1 #2 #3
  { T, F, TF }
  {
%    \end{macrocode}
%
%   Offset Arabic page numbers by 1000 so they are always greater than any
%   likely Roman page number.
%
%    \begin{macrocode}
    \regex_if_match:nnTF { \A\d+\Z } {#1}
      {
        \int_set:Nn \l_@@_first_int { #1 + 1000 }
      }
      {
        \int_set:Nn \l_@@_first_int
          { \exp_args:Ne \int_from_roman:n {#1} }
      }
    \regex_if_match:nnTF { \A\d+\Z } {#3}
      {
        \int_set:Nn \l_@@_second_int { #3 + 1000 }
      }
      {
        \int_set:Nn \l_@@_second_int
          { \exp_args:Ne \int_from_roman:n {#3} }
      }
%    \end{macrocode}
%
%   Now we just need a simple integer comparison.
%
%    \begin{macrocode}
    \if_int_compare:w \l_@@_first_int #2 \l_@@_second_int
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_page_incr:n} \marg{page number}
%
%   \medskip
%
%   Increment a page number taking into account whether it is Roman or Arabic,
%   leaving the result on the input stream. Trying to increment something
%   other than a Roman or positive Arabic number results in an empty token
%   list.
%
%    \begin{macrocode}
\cs_new:Nn \@@_page_incr:n
  {
    \regex_if_match:nnTF { \A\d+\Z } {#1}
      {
        \int_eval:n { #1 + 1 }
      }
      {
        \int_to_roman:n { \int_from_roman:n {#1} + 1 }
      }
  }
\cs_generate_variant:Nn \@@_page_incr:n { V }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Index Processing Code}
%
% The following code processes page numbers and notes for an index entry and
% produces an index entry in SBL style.
%
% \begin{macro}{\@@_set_up_hyperref:}
%
%   The \pkg{hyperref} package changes the format of the index, so needs
%   special handling at a number of points.
%
%    \begin{macrocode}
\bool_new:N     \l_@@_hyperref_bool
\regex_new:N    \l_@@_page_regex
\regex_new:N    \l_@@_page_encap_regex
\regex_new:N    \l_@@_page_with_note_regex
\regex_const:Nn \c_@@_range_regex { \A ( \d+ ) -- ( \d+ ) \Z }
\cs_new_protected:Nn \@@_set_up_hyperref:
  {
    \cs_if_exist:NTF \hyperxindexformat
      {
        \bool_set_true:N \l_@@_hyperref_bool
        \regex_set:Nn \l_@@_page_regex
          { \A \c{hyperpage} \cB\{ ( .*? ) \cE\} \Z }
        \regex_set:Nn \l_@@_page_encap_regex
          {
            \A \c{hyperxindexformat} \cB\{ ( \c{.*} .* ) \cE\}
              \cB\{ ( .*? ) \cE\} \Z
          }
        \regex_set:Nn \l_@@_page_with_note_regex
          {
            \A \c{hyperxindexformat}
              \cB\{ \c{SBLPageWithNote} \cB\{ ( .*? ) \cE\} \cE\}
              \cB\{ ( .*? ) \cE\} \Z
          }
      }
      {
        \regex_set:Nn \l_@@_page_encap_regex
          { \A ( \c{.*} .* ) \cB\{ ( .*? ) \cE\} \Z }
        \regex_set:Nn \l_@@_page_with_note_regex
          {
            \A \c{SBLPageWithNote}
              \cB\{ ( .*? ) \cE\} \cB\{ ( .*? ) \cE\} \Z
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_append_page_data:n, \@@_append_page_data:e}
%     \marg{page data}
%
%   \medskip
%
%   Create a data structure for storing and manipulating page data.
%
%    \begin{macrocode}
\keys_define:nn { sblidx / pagedata }
  {
    page  .tl_set:N = \l_@@_page_tl                    ,
    note  .tl_set:N = \l_@@_note_tl                    ,
    encap .code:n   = \cs_set_nopar:Nn \@@_encap: {#1} ,
  }
\int_new:N  \l_@@_page_data_id_int
\prop_new:N \l_@@_page_data_prop
\cs_new_protected:Nn \@@_append_page_data:n
  {
    \int_incr:N \l_@@_page_data_id_int
    \prop_put:Nen \l_@@_page_data_prop
      { \int_use:N \l_@@_page_data_id_int } {#1}
  }
\cs_generate_variant:Nn \@@_append_page_data:n { e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_@@_status_code_int}
%
%   The functions below set a status code so that the result of the most
%   recent function can be tested.
%
%    \begin{macrocode}
\int_new:N \g_@@_status_code_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_range_to_clist:nN, \@@_range_to_clist:VN,
%     \@@_range_to_clist:eN} \marg{range} \meta{list}
%
%   \medskip
%
%   Convert a range of the form \meta{integer}|--|\meta{integer} to a comma
%   separated list of integers, leaving the result in \meta{list} |clist|
%   variable. If the form is not found the input is added unaltered to
%   \meta{list}. A status code of |0| indicates that a range was found and
%   successfully added to \meta{list}.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_range_to_clist:nN
  {
    \seq_set_regex_extract_once:NNn \l_tmpb_seq \c_@@_range_regex {#1}
    \seq_if_empty:NTF \l_tmpb_seq
      {
        \clist_set:Nn #2 {#1}
        \int_gset_eq:NN \g_@@_status_code_int \c_one_int
      }
      {
        \clist_clear:N #2
        \int_step_inline:nnn
          { \seq_item:Nn \l_tmpb_seq { 2 } }
          { \seq_item:Nn \l_tmpb_seq { 3 } }
          {
            \clist_put_right:Nn #2 {##1}
          }
        \int_gzero:N \g_@@_status_code_int
      }
  }
\cs_generate_variant:Nn \@@_range_to_clist:nN { VN }
\cs_generate_variant:Nn \@@_range_to_clist:nN { eN }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_check_page:n} \marg{index item}
%
%   \medskip
%
%   Assume an \meta{index item} is a plain page or range and append it the
%   page to the \meta{page data} property list. A status code of |0| indicates
%   a page or range was successfully appended to \meta{page data}.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_check_page:n
  {
    \tl_clear:N \l_tmpa_tl
    \bool_if:NTF \l_@@_hyperref_bool
      {
        \seq_set_regex_extract_once:NNn \l_tmpa_seq \l_@@_page_regex {#1}
        \seq_if_empty:NF \l_tmpa_seq
          {
            \tl_set:Ne \l_tmpa_tl { \seq_item:Nn \l_tmpa_seq { 2 } }
          }
      }
      {
        \tl_set:Nn \l_tmpa_tl {#1}
      }
    \tl_if_empty:NTF \l_tmpa_tl
      { \int_gset_eq:NN \g_@@_status_code_int \c_one_int }
      {
        \@@_range_to_clist:VN \l_tmpa_tl \l_tmpa_clist
        \clist_map_inline:Nn \l_tmpa_clist
          {
            \@@_append_page_data:e { page = {##1} }
          }
        \int_gzero:N \g_@@_status_code_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_check_page_encap:n} \marg{index item}
%
%   \medskip
%
%   Check an \meta{index item} if it is encapsulated. If it is then append the
%   page and encap function to the \meta{page data} property list. A status
%   code of |0| indicates an encapsulated page was found and successfully
%   appended to \meta{page data}.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_check_page_encap:n
  {
    \seq_set_regex_extract_once:NNn \l_tmpa_seq \l_@@_page_encap_regex {#1}
    \seq_if_empty:NTF \l_tmpa_seq
      { \int_gset_eq:NN \g_@@_status_code_int \c_one_int }
      {
        \@@_range_to_clist:eN { \seq_item:Nn \l_tmpa_seq { 3 } } \l_tmpa_clist
        \clist_map_inline:Nn \l_tmpa_clist
          {
            \@@_append_page_data:e
              {
                page  = {##1} ,
                encap = { \seq_item:Nn \l_tmpa_seq { 2 } }
              }
          }
        \int_gzero:N \g_@@_status_code_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_check_page_with_note:n} \marg{index item}
%
%   \medskip
%
%   Check an \meta{index item} if it is in the form
%   \cs{SBLPageWithNote}\marg{note}\marg{page}. If it is then append the page
%   and note to the \meta{page data} property list. A status code of |0|
%   indicates a page with a note was found and successfully appended to
%   \meta{page data}.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_check_page_with_note:n
  {
    \seq_set_regex_extract_once:NNn
      \l_tmpa_seq \l_@@_page_with_note_regex {#1}
    \seq_if_empty:NTF \l_tmpa_seq
      { \int_gset_eq:NN \g_@@_status_code_int \c_one_int }
      {
        \@@_append_page_data:e
          {
            page = { \seq_item:Nn \l_tmpa_seq { 3 } } ,
            note = { \seq_item:Nn \l_tmpa_seq { 2 } }
          }
        \int_gzero:N \g_@@_status_code_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\endinput
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
